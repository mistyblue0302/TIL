## 상속 vs 조합

상속이란,

- 기존에 정의되어 있는 클래스의 필드와 메소드를 물려받아 새로운 클래스를 생성하는 기법
- 중복코드 제거와 기능확장을 할 수 있다.
- 클래스들의 계층적인 구조를 만들 수 있다.

### 상속의 문제

1. 하위 클래스가 상위 클래스의 구현에 의존하기 때문에 상위 클래스의 변경에 모든 하위 클래스가 영향을 받는다.

2. 상위 클래스의 public 메소드가 하위 클래스에도 노출된다.

상속은 부모 클래스와 강하게 의존하고 부모 클래스의 캡슐화를 해치고 결합도가 높아진다. 따라서 부모 클래스의 구현을 변경하면, 많은 자식 클래스를 모두 변경 해줘야 한다

- 불필요한 메소드도 상속받는 문제

![img](https://github.com/dilmah0203/TIL/blob/main/Image/Stack.png)

이 Stack 클래스는 Vector라는 클래스를 상속받고 있다.

![img2](https://github.com/dilmah0203/TIL/blob/main/Image/StackTest.png) 

문자열을 저장하는 Stack을 선언 후 Stack에서 지원하는 메소드로 문자열을 넣어주었다. Stack에서 문자열을 꺼내면 마지막에 넣은 문자열이 반환될 것이라고 예상할 수 있다. 하지만 실제 실행 결과는 예상과 다르게 두 번째에 넣은 문자열이 반환된다.

![img3](https://github.com/dilmah0203/TIL/blob/main/Image/StackTestFailed.png)

add() 메소드는 Stack의 규칙을 따르지 않기 때문이다. 원래 Stack은 나중에 들어온 원소부터 먼저 반환되어야 하는데 add() 메소드는 순서와 상관없이 특정 인덱스에 원소를 추가할 수 있게 허용하고 있다. Vector를 상속한 Stack은 자신에게 필요하지 않은 메소드를 노출할 수 밖에 없다.

### 조합은 상속의 문제점을 어떻게 해결할까?

조합이란,

- 전체를 표현하는 클래스가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용하는 방법이다.
- 상속과 달리 부분 객체의 내부 구현이 공개되지 않는다.
- 메소드를 호출하는 방식으로 public 인터페이스에 의존해서 부분 객체의 내부 구현이 변경되어도 비교적 안전하다.
- 부분 객체의 모든 퍼블릭 메소드를 공개하지 않아도 된다.

조합하려는 클래스의 인스턴스를 새로운 클래스의 private 필드로 참조하고, 인스턴스의 메소드를 호출하는 방식으로 구현한다.

### 상속과 조합은 언제 써야할까?

**상속의 목적**

1. 서브타이핑 - 다형적인 계층구조 구현(부모와 자식 행동이 호환)
2. 서브클래싱 - 다른 클래스의 코드를 재사용(부모와 자식 행동이 호환 x)

이 두가지의 서로 다른 상속의 차이는 부모 클래스의 행동과 자식 클래스의 행동의 호환여부이다. 두 객체가 서로 **Is-A** 관계이거나 클라이언트 관점에서 두 객체가 **동일한 행동**을 할 것이라 기대될 때 상속을 고려한다.

<br>

참고

[우아한Tech 상속과 조합](https://www.youtube.com/watch?v=U4OSS4jJ9ns)
