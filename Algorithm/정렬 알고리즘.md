## 정렬 알고리즘

정렬이란 데이터를 기준에 맞게 순서대로 배열하는 작업으로 탐색을 용이하게 한다.

### 선택 정렬(Selection Sort)

선택 정렬은 앞에서부터 차례대로 정렬한다. 

- 주어진 배열에서 **최소값**을 찾고 그 값을 맨 앞에 위치한 값과 교체한다. 
- 그 다음 두번째로 작은 원소를 찾아 다시 앞으로 보낸다. 모든 원소가 정렬될 때까지 반복한다.

![img](https://github.com/dilmah0203/TIL/blob/main/Image/Selection%20Sort.png)

n개의 원소가 있을 경우, (n-1) + (n-2) + (n-3) + .. + 2 + 1 => n(n-1)/2 이므로 **O(N²)의 시간 복잡도**를 가진다. 주어진 배열 안에서 교환하므로 메모리 추가가 필요없기 때문에 공간 복잡도는 O(N)이다.

### 삽입 정렬(Insertion Sort)

원소를 이미 정렬된 앞 부분 배열에서 자리를 찾아 삽입하는 정렬이다.

- 매 순서마다 해당 원소를 **앞의 정렬된 배열**에서 삽입할 수 있는 위치를 찾아 해당 위치에 넣는다.
- 해당 위치에 있던 원소부터 뒤의 원소들은 한 칸씩 밀린다.

![img](https://github.com/dilmah0203/TIL/blob/main/Image/Insertion%20Sort.png)

3은 앞의 배열에서 자기 자리를 찾는데, 9보다 작으므로 9의 앞으로 오게된다.

![img2](https://github.com/dilmah0203/TIL/blob/main/Image/Insertion%20Sort2.png)

이 과정이 끝나면 3과 9는 정렬이 되고, 같은 방식으로 5의 자리를 찾는다. 이런 방식으로 4,8,7,1까지 정렬한다.

n개의 원소가 있을 경우, (n-1) + (n-2) + (n-3) + .. + 2 + 1 => n(n-1)/2 이므로 **O(N²)의 시간 복잡도**를 가진다. 모든 데이터가 정렬되어 있는 경우는 n-1개의 원소에 대해서 비교 연산을 1번씩만 진행하면 되므로 O(N)의 시간복잡도를 가진다. 주어진 배열 안에서 교환하게 되므로 공간 복잡도는 O(N)이다.

### 버블 정렬(Bubble Sort)

버블 정렬은 첫 번째 원소부터 순차적으로 진행하며, 서로 인접한 두 원소의 대소를 비교하고 조건에 맞지 않다면 자리를 교환하며 정렬한다.

![img3](https://github.com/dilmah0203/TIL/blob/main/Image/Bubble%20Sort.png))

1회 수행하고 나면 가장 큰 원소가 맨 뒤로 이동하므로 2회 정렬 부터는 맨 끝 원소를 제외하고 정렬한다. 이렇게 1회전을 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.

n개의 원소가 있을 경우, (n-1) + (n-2) + (n-3) + .. + 2 + 1 => n(n-1)/2 이므로 **O(N²)의 시간 복잡도**를 가진다. 주어진 배열 안에서 교환하게 되므로 공간 복잡도는 O(N)이다.

### 병합 정렬(Merge Sort)

분할 정복(Divide And Conquer) 알고리즘으로, 배열을 가운데 기준으로 분할한 다음 이 둘을 합하면서 정렬해나간다.

- 배열이 더 이상 쪼개지지 않을 때(원소가 하나일 때)까지 반으로 분할한다.
- 분할된 부분 배열들을 순서에 맞게 병합한다. 이 과정에서 정렬이 이루어진다.
- 최종적으로 병합이 완료되면 배열이 정렬되어 있다.

![img3](https://github.com/dilmah0203/TIL/blob/main/Image/Merge%20Sort.png)

원소가 하나씩 남을 때 까지 배열 중앙을 기준으로 반으로 분할한다. 다음에 배열을 병합하는 과정에서 정렬이 일어난다.

![img3](https://github.com/dilmah0203/TIL/blob/main/Image/Merge%20Sort2.png)

병합 시에 어떤 방식으로 정렬이 이루어질까?

![img4](https://github.com/dilmah0203/TIL/blob/main/Image/Merge%20Sort3.png)

우선 3459와 178이라는 두 배열은 앞선 과정에 의해 정렬이 되어 있기 때문에 맨 앞에 있는 원소들은 가장 작다. 데이터 크기 만큼의 임시 배열을 생성하고, 1과 3을 비교해서 더 작은 것을 채워나가는 방식으로 정렬을 한다. 임시 배열을 순회하면서 원래 배열에 복사해 넣는다.

n개의 원소가 있을 경우, 분할하는 과정에서는 배열을 반으로 나누는 과정이 일어나고 상수시간이 걸린다. 병합하는 과정에서 하나로 쪼개진 원소가 n개의 원소가 되려면 2^x=n에서 x번의 과정을 거치면 된다. n개의 원소가 있을 경우 x = log2N 즉, O(logN)의 시간이 소모되고 매 단계에서 배열의 모든 원소를 정렬 해야하므로 필요한 시간은 O(N)이다. 따라서 병합 정렬의 **시간복잡도는 O(NlogN)이다.** 정렬 과정에서 임시 배열이 필요하기 때문에 공간 복잡도는 O(2N)이다.

### 힙 정렬(Heap Sort)

완전 이진 트리를 기본으로 하는 힙(Heap) 자료구조를 기반으로한 정렬 방식이다. 부모 노드가 자식 노드보다 크거나 작은 속성을 만족하며 각각 최대 힙과 최소 힙이라고 한다. 정렬에 유용하다.

힙을 구성하는데 필요한 시간 복잡도는 한 번 자식 노드로 내려갈 때마다 노드의 개수가 2배씩 증가하기 때문에 O(logN)이고 데이터의 개수가 n개 이므로 전체 트리를 힙 구조로 만드는 **시간 복잡도는 O(NLogN)이다.**

### 퀵 정렬(Quick Sort)

퀵 정렬도 분할 정복 알고리즘으로, **임의의 Pivot(배열에 있는 선택된 원소)을** 사용한다. 병합 정렬과의 가장 큰 차이점은 병합 정렬은 중앙을 기준으로 분할하기 때문에 양쪽 개수가 거의 균등한 균등 분할이 일어나지만, 퀵 정렬의 경우 임의의 Pivot을 정하기 때문에 비균등 분할이다.

1. 임의의 Pivot을 정한다.
2. 배열의 양 끝에 Left와 Right 포인트를 지정한다.
3. 각 조건에 맞게 두 포인터를 이동시킨다.
    - Left는 Pivot보다 작으면 ->, 아니면 stop
    - Right는 Pivot보다 크면 <-, 아니면 stop
4. 포인터가 둘 다 정지하면 데이터를 swap한다.
5. Left와 Right를 한 칸 씩 이동시킨다. 
6. Left와 Right가 엇갈리는 순간 종료된다.

![img5](https://github.com/dilmah0203/TIL/blob/main/Image/Quick%20Sort.png)

Leff(9)가 Pivot(4)보다 작지 않고, Right(1) 역시 4보다 크지 않으므로 이동시키지 않는다. 그 뒤에 9와 1은 데이터 스왑을 하게 되고 Left와 Right를 한 칸씩 이동시킨다.

![img6](https://github.com/dilmah0203/TIL/blob/main/Image/Quick%20Sort2.png)

Left(3)은 Pivot(4)보다 작으므로 포인터가 오른쪽으로 한 칸 움직이고 5는 4보다 작지 않으니 이동하지 않는다. Right(7)은 4보다 크기 때문에 포인터가 왼쪽으로 한 칸 움직인다. 

![img7](https://github.com/dilmah0203/TIL/blob/main/Image/Quick%20Sort3.png)

8은 또한 4보다 크므로 왼쪽으로 한 칸 움직이고 4는 4보다 크지 않기 때문에 이동하지 않는다. 

![img8](https://github.com/dilmah0203/TIL/blob/main/Image/Quick%20Sort4.png)

두 포인터가 멈췄으면 데이터를 스왑하고 Left와 Right를 한 칸씩 이동시킨다. 

![img9](https://github.com/dilmah0203/TIL/blob/main/Image/Quick%20Sort5.png)

Left와 Right가 교차되었으므로 종료된다. Pivot(4)의 왼쪽은 Pivot보다 작은 값들로, 오른쪽은 큰 값들로 분할이 된다.

퀵 정렬은 일반적으로 가장 빠른 정렬 알고리즘으로 **평균적으로는 O(NLogN)이다.** 하지만 이미 정렬된 배열에 적용할 경우 최악 O(N²)의 시간복잡도를 가진다. [1,2,3,4,5]라는 배열이 있을 때 가장 처음값인 1을 Pivot으로 선택하게 되면 1을 기준으로 1보다 작은 값은 모두 왼쪽에 두고 큰 값은 모두 오른쪽에 두어야 하는데 1보다 작은 값은 없기 때문에 5부터 2까지 내려오면서 1과 비교하는 연산이 n-1번 수행된다. 첫 분할이 끝나고 나면 다음 Pivot은 2로 지정이 되고 이 때 역시 비교 연산이 n-1번 수행된다. 따라서 Pivot이 n에 도달할 때까지 비교 연산이 계속 진행되기 때문에 시간 복잡도는 (n-1) * n이 되어 O(N^2)이 된다. 교환에 있어서 공간이 따로 필요없기 때문에 공간복잡도는 O(N)이다. 

### Java에서의 Sort

- Dual Pivot Quick Sort
    - primitive 타입을 정렬할 때 사용
    - Pivot을 두개 쓰는 정렬 알고리즘으로, 하나만 쓰는 것보다 일반적으로 빠름
    - Arrays.sort()

- Tim Sort
    - reference 타입을 정렬할 때 사용
    - 삽입 정렬과 병합 정렬을 사용
    - Collections.sort()

<br>

참고

[우아한Tech 정렬 알고리즘](https://www.youtube.com/watch?v=8c-Q8anmJcM&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=2)
