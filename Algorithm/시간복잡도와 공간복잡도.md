## 빅오 표기법

- **빅오 표기법**은 알고리즘의 효율성을 비교하기 위해 사용한다. 
- 알고리즘의 효율성은 입력 데이터 n개가 주어졌을 때, 연산의 횟수를 의미한다. 
- 빅오 표기법은 보통 알고리즘의 시간 복잡도와 공간 복잡도를 나타낼 때 사용된다.

```
O(1) - O(logN) - O(N) - O(NlogN) - O(N²) - O(2ᴺ) //왼쪽으로 갈수록 빠르다
```

- O(1) : 상수 시간으로, 입력값의 크기와 상관없이 일정한 시간이 걸린다.
- O(logN) : 알고리즘 수행 마다 찾아야할 대상이 절반으로 줄어든다.
- O(N) : 입력값이 증가함에 따라 시간도 같은 비율로 증가한다.
- O(N²) : 입력값이 증가함에 따라 시간이 제곱수의 비율로 증가한다.

## 시간 복잡도

- 알고리즘을 위해 필요한 연산 횟수, 특정한 크기의 입력에 대하여 얼마나 **오래걸리는지**를 의미
- 가장 빠르게 증가하는 항만을 고려한다.

```java
int[] array = {1,2,3,4,5}; //n개의 데이터
int sum = 0; //상수 시간(일정한 시간) 

for(int value : array)
    sum += value; //n번
```

sum 변수에 0을 대입하는 연산도 있지만, n이 커짐에 따라 무시할 수준으로 작아진다. 따라서 영향력이 큰 부분은 연산을 수행하는 반복문이고, 시간 복잡도를 O(N)이라고 표기한다.

```java
int sum = 0;
for (int i = 0; i < N; i++) { //0부터 N-1까지 반복
    for (int j = 0; j < i; j++) { //i만큼 반복
        sum += j;
    }
}
```

`sum += j;` 연산은 첫 번째 반복문에서는 0번, 두 번째 i일 때는 1번 즉, 0+1+2+…+(N-1) = N*(N-1)/2번 반복한다. 따라서 O(N²)이다.


## 공간 복잡도

- 알고리즘을 위해 필요한 메모리의 양, 특정한 크기의 입력에 대하여 얼마나 **많은 메모리를 차지하는지**를 의미
- 변수, 자료구조, 함수 호출, 할당 등이 영향을 미친다.

```java
int a = 5; //공간이 하나 생성되므로 O(1)
```

```java
int factorial(int n)
{
    if ( n == 1 )
      return 1;
    else
      return n * factorial(n -1); //재귀 함수는 n만큼 수행되기 때문에 변수n이 n개만큼 만들어짐(공간 복잡도는 O(n))
}
```
