## JPQL 경로 표현식

- 쿼리문 작성 시 점(.)을 이용하여 객체의 값에 접근할 수 있다.
- 이처럼 점(.)을 이용해 객체 그래프를 탐색하는 것을 경로 표현식이라 한다.

~~~java
SELECT m.username    // 상태 필드
    FROM Member m
        JOIN m.team t    // 단일 값 연관 필드
        JOIN m.orders o    // 컬렉션 값 연관 필드
WHERE t.name = 'teamA'
~~~

- 상태 필드
  - 단순히 값을 저장하기 위해 사용하는 필드
  - 상태 필드 경로는 추가 탐색이 불가능하다. (ex:m.username)
  - 경로 탐색의 끝이기 때문에 m.username 이후 추가 탐색 불가

~~~java
// JPQL
SELECT m.username FROM Member m

// SQL
SELECT m.username FROM Member m
~~~

- 연관 필드
  - 연관관계를 위한 필드
  - **묵시적으로 내부 조인이 발생**
  - 단일 값 연관 필드 : @ManyToOne, @OneToOne, 대상이 엔티티 (ex: m.team), 추가 탐색이 가능
  - 컬렉션 값 연관 필드 : @OneToMany, @ManyToMany, 대상이 컬렉션 (ex: m.orders), 추가 탐색이 불가능, 하지만 FROM 절에서 명시적 조인을 통해 별칭을 얻으면 탐색 가능.

~~~java
// JPQ
SELECT o.member FROM Order o

// SQL(묵시적 조인 발생)
SELECT m.* FROM Orders o INNER JOIN Member m ON o.member_id = m.id

// 추가 탐색 가능
SELECT o.member.name FROM Order o
~~~

~~~java
// JPQL 
SELECT t.members FROM Team t

// SQL(묵시적 조인 발생)
SELECT t.members FROM Team t INNER JOIN Member m ON m.team_id = t.id

// 별칭을 통해 추가 탐색 가능
SELECT m.username FROM Team t JOIN t.members m
~~~

- 정리

~~~java
// 가능, 내부 조인이 2번 발생
SELECT o.member.team FROM Order o

// 가능
SELECT t.members FROM Team t

// 불가능, 추가 탐색 불가(컬렉션 값 연관 필드)
SELECT t.members.username FROM Team t

// 가능, 명시적 조인을 통해 탐색
SELECT m.username FROM Team t JOIN t.members m
~~~

- 명시적 조인과 묵시적 조인
  - 명시적 조인 : JOIN을 쿼리문에 직접 작성
  - 묵시적 조인 : 경로 표현식에 의해 묵시적으로 조인이 발생하는 것(INNER JOIN 발생)

~~~java
// 명시적 조인
SELECT m FROM Member m JOIN m.team t

// 묵시적 조인
SELECT m.team FROM Member m
~~~

- 주의 사항
  - 묵시적 조인은 항상 내부 조인(INNER JOIN)
  - 컬렉션은 추가 탐색이 불가능하다. 추가 탐색을 하려면 명시적 조인을 통해 별칭을 얻어서 사용해야 한다.
  - 경로 탐색은 주로 SELECT, WHERE 절에서 사용하지만, 묵시적 조인으로 인해 SQL의 FROM 절에 영향을 준다.
  - 단순한 경우에는 문제가 없으나, 실무에서는 매우 복잡하고 규모가 크기 때문에 성능 저하가 발생할 수 있다.
  - 따라서 되도록 명시적 조인을 사용하는 것이 좋다.
 
## JPQL 페치조인(fetch join)

- SQL 조인 종류가 X
- JPQ에서 **성능 최적화**를 위해 제공하는 기능
- 연관된 Entity나 컬렉션을 **SQL 한번에 함께 조회**하는 기능
- join fetch 명령어 사용

### 엔티티 페치 조인

페치 조인을 사용하여 Member 엔티티를 조회하면서, Team 엔티티를 한 번의 쿼리로 함께 조회한다.(SQL 한 번에)

~~~java
// JPQL
SELECT m FROM Member m JOIN FETCH m.team

// SQL
SELECT M.*, T.* FROM MEMBER M INNER JOIN TEAM T ON M.TEAM_ID = T.ID
~~~

SQL을 보면 회원 뿐만 아니라 **팀(T.*)**도 함께 **SELECT**한다.

![img](https://github.com/mistyblue0302/TIL/blob/main/Image/Fetch%20Join.jpg)

- 엔티티 페치 조인 JPQL 코드에서 select m으로 회원 엔티티만 선택하여 실행하면
- 실행된 SQL에서는 SELECT M.*, T.*로 Member와 연관된 Team도 함께 조회한다.
- Member와 Team 객체가 객체 그래프를 유지하면서 조회된 것

**적용 전**

~~~java
String jpql = "select m from Member m";

List<Member> members = em.createQuery(jpql, Member.class).getResultList();

for (Member member : members) {
    // 페치 조인 없이 회원과 팀을 함께 조회
		System.out.println("username = " + member.getUsername() + ", " +
				"teamname = " + member.getTeam().name());
}
~~~

~~~java
username = 회원1, teamname = 팀A (SQL)
username = 회원2, teamname = 팀A (1차캐시)
username = 회원3, teamname = 팀B (SQL)
~~~

처음엔 Member를 조회하는 쿼리가 실행된다. 지연로딩으로 설정되어 있기 때문에 Team은 프록시 객체로 설정된다. 이후 Member에서 getTeam().getName() 메소드를 호출할 때 프록시 객체가 아닌 DB에 쿼리를 날리게 된다.(2회) 그러면 영속성 컨텍스트에 Team A가 들어가게 된다. 다음 회원2는 Team A가 영속성 컨텍스트에 존재하기 때문에 캐시해서 가져온다. 회원3은 Team B가 영속성 컨텍스트에 존재하지 않기 때문에 쿼리를 날려 영속성 컨텍스트에 올리고 결과를 반환한다.(3회)

> 만약 회원이 100명이면 어떻게 될까?

회원이 다 다른팀 소속이라면 회원 조회 쿼리 1번과 각 회원마다의 팀 조회 쿼리 100개가 나간다. N+1 문제가 발생한다.

**적용 후**

~~~java
String jpql = "select m from Member m join fetch m.team";

List<Member> members = em.createQuery(jpql, Member.class).getResultList();

for (Member member : members) {
		System.out.println("username = " + member.getUsername() + ", " +
				"teamname = " + member.getTeam().name());
}
~~~

페치 조인을 적용하여 한 번에 Team을 가지고 올 수 있다. select 쿼리 한 번으로 가져온다. 이때 Team은 프록시가 아닌 실제 엔티티가 담긴다.

~~~java
select
	member0_.id as id1_0_0_,
	team1_.TEAM_ID as team_id1_1_1_,
	member0_.age as age2_0_0_,
	member0_.TEAM_ID as team_id4_0_0_,
	member0_.username as username3_0_0_,
	team1_.name as name2_1_1_ 
from
	Member member0_ 
inner join
	Team team1_ 
	on member0_.TEAM_ID=team1_.TEAM_ID
~~~

- 페치 조인을 사용하면 회원과 팀을 지연 로딩(LAZY)으로 설정해도 지연 로딩이 일어나지 않는다.
- 실제 엔티티를 조회하므로 회원 엔티티가 영속성 컨텍스트에서 분리되어 준영속 상태가 되어도 연관된 팀을 조회할 수 있다.

![img](https://github.com/mistyblue0302/TIL/blob/main/Image/Fetch%20Join2.jpg)







