## 연관관계가 필요한 이유

<예제 시나리오>
- 회원과 팀이 있다.
- 회원은 하나의 팀에만 소속될 수 있다.
- 회원과 팀은 다대일 관계다.


### 객체를 테이블에 맞추어 모델링(참조 대신에 테이블에 맞춰서 외래키 값을 그대로 가지고 있음)

![img](https://github.com/mistyblue0302/TIL/blob/main/Image/Correlation.png)

~~~java
@Entity
public class Member {

  @Id @GeneratedValue
  private Long id;

  @Column(name = "USERNAME") 
  private String name;

  @Column(name = "TEAM_ID")
  private Long teamId;
  ...
}

@Entity
public class Team {

  @Id @GeneratedValue
  private Long id;

  private String name;
  ...
}
~~~

아래는 팀과 회원을 저장하는 코드이다.

~~~java
//팀 저장
Team team = new Team();
team.setName("TeamA"); 
em.persist(team);

//회원 저장
Member member = new Member();
member.setName("member1");
member.setTeamId(team.getId());
em.persist(member);
~~~

만약 회원의 팀을 찾으려면 어떻게 할까?

~~~java
Member findMember = em.find(Member.class, member.getId());

Long findTeamId = findMember.getId();
Team findTeam = em.find(Team.class, findTeamId);
~~~

연관관계가 없다면 회원의 팀을 가져오는데 계속 꺼내와야 한다. 회원을 꺼내오고, 회원의 id를 가져와 다시 팀을 가져오는 과정이 필요하다. 객체 지향스럽지 않은 코드가 된다.

**객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다.**

- **테이블은 외래 키로 조인**을 사용해서 연관된 테이블을 찾는다.
- **객체는 참조**를 사용해서 연관된 객체를 찾는다.
- 테이블과 객체 사이에는 이런 큰 간격이 있다.

## 단방향 연관관계

![img](https://github.com/mistyblue0302/TIL/blob/main/Image/Correlation2.png)

- **객체 연관관계**
  - 회원(Member)은 `Member.team` 필드로 팀(Team) 객체와 연관관계를 맺는다.
  - 회원 객체와 팀 객체는 **단방향 관계**이다. 회원은 `member.getTeam()`을 통해 팀을 알 수 있지만 팀은 소속된 회원을 알 수 없다. team -> member를 접근하는 필드가 없기 때문이다.
- **테이블 연관관계**
  - 회원은 TEAM_ID 외래키로 팀 테이블과 연관관계를 맺는다.
  - 회원 테이블과 팀 테이블은 **양방향 관계**이다. 회원 테이블의 TEAM_ID 외래키를 통해 회원과 팀을 JOIN할 수 있다.
  - 회원과 팀을 JOIN하는 SQL
    ~~~SQL
    SELECT *
    FROM MEMBER M
    JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
    ~~~
  - 팀과 회원을 JOIN하는 SQL
    ~~~SQL
    SELECT *
    FROM TEAM T
    JOIN MEMBER M ON T.TEAM_ID = M.TEAM_ID
    ~~~
- **객체 연관관계 vs 테이블 연관관계**
  - 객체는 참조(주소)로 연관관계를 맺는다.
  - 테이블은 외래 키로 연관관계를 맺는다.
  - 참조를 사용하는 객체의 연관관계는 단방향이다. 객체간에 연관관계를 양방향으로 만들고 싶으면 반대쪽에도 필드를 추가해서 참조를 보관해야 한다. 이렇게 양쪽에서 서로 참조하는 것을 양방향 연관관계라고 하지만 이것은 **양방향 관계가 아니라 서로 다른 단방향 관계 2개**이다.
  - 외래 키를 사용하는 테이블의 연관관계는 양방향이다.(A JOIN B가 가능하면 반대로 B JOIN A도 가능) 

### 연관관계 사용

~~~java
@Entity
public class Member {

  @Id @GeneratedValue
  private Long id;

  @Column(name = "USERNAME") 
  private String name;

  @ManyToOne
  @JoinColumn(name = "TEAM_ID")
  private Team team;
  
  //getter, setter
}
~~~

~~~java
@Entity
public class Team {

  @Id @GeneratedValue
  private Long id;
  private String name;
  
  //getter, setter
}
~~~

**연관관계 저장**

~~~java
//팀 저장
Team team = new Team();
team.setName("TeamA");
em.persist(team);

//회원 저장
Member member = new Member(); 
member.setName("memberA");
member.setTeam(team); //단방향 연관관계 설정, 참조 저장 
em.persist(member);
~~~

이전 코드와 다른점은 member에 teamId를 넣지 않고, team을 넣어준다.

**연관관계 조회**

~~~java
//조회
Member findMember = em.find(Member.class, member.getId());
//참조를 사용해서 연관관계 조회
Team findTeam = findMember.getTeam();
~~~

**연관관계 수정**

~~~java
Team teamB = new Team();
teamB.setName("TeamB");
em.persist(teamB);

member.setTeam(teamB);
~~~

## @ManyToOne, @JoinColumn

**@ManyToOne** : 다대일(N:1) 관계를 나타내는 매핑 애노테이션

속성|기능|기본값
 :---|:---|:---
 optional|false로 설정하면 연관된 엔티티가 항상 있어야 한다|true
 fetch|글로벌 패치 전략을 설정한다.|@ManyToOne=FetchType.EAGER, @OneToMany=FetchType.LAZY
 cascade|영속성 전이 기능을 사용한다.|
 targetEntity|연관된 엔티티의 타입 정보를 설정한다. 이 기능은 거의 사용하지 않음|
 
**@JoinColumn** : 외래키를 매핑할 때 사용

속성|기능|기본값
 :---|:---|:---
 name|매핑할 외래 키 이름|"필드명" + "_" + "참조하는 테이블의 기본 키 컬럼명"
 referencedColumnName|외래 키가 참조하는 대상 테이블의 컬럼명|참조하는 테이블의 기본 키 컬럼명
 foreignKey(DDL)|외래 키 제약조건을 직접 지정할 수 있다. 이 속성은 테이블을 생성할 때만 사용한다.|
 unique|@Column의 속성과 같다|
 nullable|@Column의 속성과 같다|
 insertable|@Column의 속성과 같다|
 updatable|@Column의 속성과 같다|
 columnDefinition|@Column의 속성과 같다|
 table|@Column의 속성과 같다|
 
 > **JoinColumn 어노테이션은 생략 가능하다.**
 @JoinColumn을 생략하면 외래 키를 찾을 때 기본 전략을 사용한다. 기본 전략은 필드명 + _ + 참조하는 테이블의 컬럼명이다.

