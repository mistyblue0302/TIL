## 상속관계 매핑

- 객체는 상속관계가 존재하지만, 관계형 데이터베이스는 상속 관계 x
- 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사
- 상속관계 매핑이라는 것은 객체의 상속 구조와 DB의 슈퍼타입 서브타입 관계를 매핑하는 것

![img](https://github.com/mistyblue0302/TIL/blob/main/Image/Inheritance%20Mapping.PNG)

슈퍼타입 서브타입 논리 모델을 실제 물리 모델인 테이블로 구현하는 방법은 3가지가 있다.

- 각각의 테이블로 변환
  - 모두 테이블로 만들고 조회할 때 조인을 사용 -> 조인 전략
- 통합 테이블로 변환
  - 모든 칼럼을 하나의 테이블로 구성 -> 단일 테이블 전략
- 서브타입 테이블로 변환
  - 서브 타입 테이블로 변환 -> 구현 클래스마다 테이블 전략

### 주요 어노테이션

- @Inheritance(strategy=InheritanceType.XXX)
  - JOINED: 조인 전략
  - SINGLE_TABLE: 단일 테이블 전략
  - TABLE_PER_CLASS: 구현 클래스마다 테이블 전략
- @DiscriminatorColumn(name=“DTYPE”)
  - 부모 클래스에 구분 컬럼을 지정한다. 이 컬럼으로 저장된 자식 테이블을 구분할 수 있다.(기본값은 DTYP)
- @DiscriminatorValue(“XXX”)
  - 엔티티를 저장할 때 구분 컬럼에 입력할 값을 지정한다.(기본값은 엔티티명)

 ## 조인 전략

조인 전략은 엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아 기본 키 + 외래 키로 사용하는 전략이다.

![img](https://github.com/mistyblue0302/TIL/blob/main/Image/Inheritance%20Mapping2.PNG)

~~~java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@DiscriminatorColumn // 하위 테이블의 구분 컬럼 생성(default = DTYPE)
public class Item {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private int price;
}
~~~

~~~java
@Entity
@DiscriminatorValue("A")
public class Album extends Item {

    private String artist;
}
~~~

~~~java
@Entity
@DiscriminatorValue("M")
public class Movie extends Item {

    private String director;
    private String actor;
}
~~~


~~~java
@Entity
@DiscriminatorValue("B")
public class Book extends Item {

    private String author;
    private String isbn;
}
~~~

- Movie 객체를 저장하면?
  - insert 쿼리가 두개 나간다.
  - Item, Movie 테이블 저장
  - DTYPE에 **클래스 이름**이 디폴트로 저장된다.

~~~java
Movie movie = new Movie();
movie.setDirector("A");
movie.setActor("B");
movie.setName("바람과함께사라지다");
movie.setPrice(30000);

em.persist(movie);

tx.commit();
~~~

|ID|NAME|PRICE|DTYPE|
|---|-----|----|----|
|1|바람과함께사라지다|30000|M|
			
|ID|DIRECTOR|ACTOR|
|---|-----|----|
|1|A|B|		

- 장점
  - 테이블 정규화
  - 외래 키 참조 무결성 제약조건 활용가능
    - 자식 테이블의 기본 키가 부모 테이블의 기본 키를 참조하므로, 외래 키 제약 조건을 통해 데이터의 무결성을 보장
    - Movie 테이블의 id는 Item 테이블의 id를 외래 키로 참조하는데, 부모 데이터가 삭제되면 자식 데이터도 자동으로 삭제되거나 부모 데이터가 없는 자식 데이터의 삽입이 방지
  - 저장공간 효율화
- 단점
  - 조회시 조인을 많이 사용, 성능 저하
  - 조회 쿼리가 복잡함
  - 데이터 저장시 INSERT SQL 2번 호출
    
 ## 단일 테이블 전략

단일 테이블 전략은 슈퍼타입 서브타입의 모든 컬럼을 하나의 테이블로 구성한다. 전략만 바꿔주면 된다.

![img](https://github.com/mistyblue0302/TIL/blob/main/Image/Inheritance%20Mapping3.PNG)

- 구분 컬럼을 통해 저장된 타입을 구분한다.
  - 구분 컬럼(@DiscriminatorColumn)을 반드시 사용한다.

|ID|NAME|PRICE|DTYPE|ARTIST|DIRECTOR|ACTOR|AUTHOR|ISBN|
|----|----|----|----|----|----|----|----|----|
|1|바람과함께사라지다|30000|M|NULL|A|B|NULL|NULL|
  
- 장점
  - 조인이 필요 없으므로 일반적으로 성능이 빠르다.
  - 조회 쿼리가 단순하다.
- 단점
  - 자식 엔티티가 매핑한 컬럼은 모두 null 허용
  - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 상황에 따라서 조회 성능이 오히려 느려질 수 있다.

 ##

- @PrimaryKeyJoinColumn(name = "book_id")
  - 자식 테이블의 기본 키 컬럼명을 지정한다. Book 엔티티에 기본 키 + 외래 키의 컬럼명은 book_id로 된다.
