## 기본값 타입

- **엔티티 타입**
  - @Entity로 정의하는 객체
  - pk값으로 관리가 되기때문에 데이터가 변해도 식별자로 지속해서 추적 가능
  - 예) 회원 엔티티의 키나 값을 변경해도 식별자로 인식 가능
- **값 타입**
  - int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
  - 식별자가 없고 값만 있으므로 변경시 추적 불가
  - 에) 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체

### 값 타입 분류

- **기본값 타입**
  - 자바 기본 타입(int, double)
  - 래퍼 클래스(Integer, Long)
  - String
  - 생명주기를 엔티티에 의존
    - 예) 회원을 삭제하면 이름, 나이 필드도 함께 삭제 
- **임베디드 타입**(embedded type, 복합 값 타입)
- **컬렉션 값 타입**(collection value type)
   
## 임베디드 타입

- 새로운 값 타입을 직접 정의해서 사용할 수 있는데, JPA에서는 이것을 임베디드 타입(embedded type)이라 한다.
- 주로 기본값 타입을 모아서 만들어서 복합 값 타입이라고 한다.
- 중요한 것은 직접 정의한 임베디드 타입도 int와 String처럼 같은 값 타입이다.(엔티티가 아니다)

~~~java
@Entity
public class Member {
  
  @Id @GeneratedValue
  private Long id;
  private String name;
  
  // 근무 기간
  private LocalDateTime startDate;
  private LocalDateTime endDate;
  
  // 집 주소 
  private String city;
  private String street;
  private String zipcode;
}
~~~

위 엔티티는 회원 엔티티로 다음과 같이 설명할 수 있다.

> 회원 엔티티는 이름, 근무 시작일, 근무 종료일, 주소 도시, 주소 번지, 주소 우편 번호를 가진다.

하지만 이렇게 설명하는 것보다, 아래처럼 추상화해서 쉽게 설명하는 편이 낫다.

> 회원 엔티티는 이름, 근무 기간, 집 주소를 가진다.

근무 기간과 주소 타입을 따로두고 코드를 명확하게 분리할 수 있다.

~~~java
@Entity
public class Member {
  
  @Id @GeneratedVAlue
  private Long id;
  private String name;
  
  @Embedded
  private Period workPeriod;	// 근무 기간
  
  @Embedded
  private Address homeAddress;	// 집 주소
}
~~~

~~~java
@Embeddable
public class Period {
  
  private LocalDateTime startDate;
  private LocalDateTime endDate;

  public boolean isWork () {
    // 값 타입을 위한 메소드 정의가능
  }

  // getter, setter
}
~~~

~~~java
@Embeddable
public class Address {
  
  @Column(name="city") // 매핑할 컬럼 정의 가능
  private String city;
  private String street;
  private String zipcode;

  // getter, setter
}
~~~

- `@Embeddable`: 값 타입을 정의하는 곳에 표시
- `@Embedded`: 값 타입을 사용하는 곳에 표시
- 임베디드 타입은 **기본 생성자가 필수**
  
임베디드 타입은 엔티티의 값일 뿐이다. 임베디드 타입으로 빼서 관리를 해도 결국 **`Member` 테이블에 변화는 없다.** 임베디드 타입으로 만들어준 `Period`와 `Address`의 필드가 모두 `Member`테이블에 들어가있다. 또한 임베디드 타입의 값이 null이면 즉 넣어주지 않으면 해당하는 컬럼들은 모두 null로 채워진다.

### 임베디드 타입의 장점

- 재사용
- 높은 응집도
- `Period.isWork()`처럼 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있음
- 임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존함

### 임베디드 타입과 연관관계

임베디드 타입은 값 타입을 포함하거나 엔티티를 참조할 수 있다.

~~~java
@Embeddable
public class Address {
  
  private String city;
  private String street;
  private String zipcode;

  privater Member member; // 다른 엔티티도 참조 가능

  // getter, setter
}
~~~

### `@AttributeOverride` : 속성 재정의

- 한 엔티티에서 같은 값 타입을 사용하면?
- 컬럼 몀이 중복됨

회원에게 주소가 하나 더 필요할 경우 어떻게 해야될까?

~~~java
@Entity
public class Member {
  
  @Id @GeneratedVAlue
  private Long id;
  private String name;
  
  @Embedded
  private Period workPeriod;

  @Embedded
  private Address homeAddress;	

  @Embedded
  private Address workAddress;	
}
~~~

두 객체 모두 `city`, `street`, `zipcode` 필드를 가지고 있다. 만약 별도의 설정을 하지 않으면, 두 `Address` 객체의 필드들이 동일한 컬럼명으로 데이터베이스 테이블에 매핑된다.

아래와 같이 `@AttributeOverride`를 사용하여 매핑정보를 재정의할 수 있다.

~~~java
@Entity
public class Member {
  
  @Id @GeneratedVAlue
  private Long id;
  private String name;
  
  @Embedded
  private Period workPeriod;

  @Embedded
  private Address homeAddress;	

  @Embedded
  @AttributeOverrides({
    @AttributeOverride(name="city", column=@Column(name="WORK_CITY")),
    @AttributeOverride(name="street", column=@Column(name="WORK_STREET")),
    @AttributeOverride(name="zipcode", column=@Column(name="WORK_ZIPCODE"))
  })
  private Address workAddress;	
}
~~~

생성된 테이블은 다음과 같다.

~~~java
CREATE TABLE MEMBER (
  id bitgint not null,
  name varchar(255),
  startDate timestamp,
  endDate timestamp,
  city varchar(255),
  street varchar(255),
  zipcode varchar(255),
  WORK_CITY varchar(255),
  WORK_STREET varchar(255),
  WORK_ZIPCODE varchar(255),
)
~~~

## 값 타입과 불변 객체

## 값 타입의 비교

## 값 타입의 컬렉션
