## 프록시 기초

엔티티 조회는 2가지 방식으로 할 수 있는데,

- em.find() vs em.getReference()
  - em.find() : DB를 통해서 실제 엔티티 객체 조회
  - em.getReference() : **DB 조회를 미루는 가짜(프록시) 엔티티 객체 조회** -> DB에 쿼리가 나가지 않는다. **실제 사용될 시점에 DB조회가 이뤄짐**

`getReference()`를 사용하면 가짜 엔티티 객체를 조회하게 되는데, 이때 이 가짜 엔티티를 **프록시**라 한다.
 
## 프록시란

- 실제 클래스를 상속 받아서 만들어짐
- 실제 클래스와 겉 모양이 같다
- 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됨

![img](https://github.com/mistyblue0302/TIL/blob/main/Image/JPA_Proxy.png)

- 프록시 객체는 실제 객체의 참조(target)을 보관
- **프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출**

### 프록시 객체의 초기화 

프록시 객체의 초기화 과정은 아래와 같다.

~~~java
Member member = e.getReference(Member.class, "id1");
member.getName();
~~~

![img](https://github.com/mistyblue0302/TIL/blob/main/Image/JPA_Proxy2.png)
- `em.getReference(Member.class, "id1");`를 호출하면 JPA는 Member 엔티티의 실제 객체 대신 해당 엔티티의 **프록시 객체**를 반환
- `member.getName()` 메소드가 호출되면 이때 프록시 객체는 실제 엔티티를 참조하기 위해 **초기화 요청**(target은 아직 null 상태)
- 그러면 JPA는 영속성 컨텍스트에 식별자(id1)에 해당하는 Member 엔티티가 존재하는지 확인 후 없다면, 
- id1에 해당하는 Member 엔티티를 DB에서 조회하여 실제 엔티티 객체와 target을 연결해준다.
- 이후 `getName()` 호출은 이제 프록시 객체가 아닌, 실제 Member 엔티티의 `getName()` 메소드가 호출되고 Member 엔티티에 저장된 name 값을 반환

### 프록시의 특징

- 프록시 객체는 처음 사용할 때 한 번만 초기화
- 프록시 객체를 초기화 할 때, **프록시 객체가 실제 엔티티로 바뀌는 것은 아님**. 초기화되면 프록시 객체를 통해 **실제 엔티티 접근 가능**하다.
- **프록시 객체는 원본 엔티티를 상속받으므로 타입 체크시 주의해야 한다.**( == 비교 실패, 대신 instance of 사용)
- **영속성 컨텍스트에 찾는 엔티티가 이미 있으면 `em.getReference()`를 호출해도 실제 엔티티를 반환한다.**
- **영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시 초기화시 문제가 발생한다.**

### 프록시 확인

- 프록시 인스턴스의 초기화 여부 확인 : `PersistenceUnitUtil.isLoaded(Object entity)`를 사용하여 엔티티가 프록시 객체인지, 실제 데이터가 로드되었는지 확인
- 프록시 클래스 확인 방법: `entity.getClass().getName()` 출력 (..javasist.. or HibernateProxy...)
- 프록시 강제 초기화 : `Hibernate.initialize(entity);`, 프록시 객체를 강제로 초기화하여 실제 엔티티를 로드
- 참고: JPA 표준은 강제 초기화가 없다. 강제 호출 : `member.getName()`, `member.getName()` 메소드를 호출하면 프록시 객체가 초기화되어 데이터베이스에서 실제 값을 가져온다.





